<!DOCTYPE HTML>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fluid Sim</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Arial', sans-serif;
      background: linear-gradient(120deg, #f0f2f5, #e2e6ea);
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      color: #333;
    }

    .container {
      text-align: center;
      padding: 40px;
      background: #ffffff;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
      border-radius: 15px;
      max-width: 850px;
      width: 100%;
    }

    h2 {
      margin-bottom: 30px;
      color: #333;
      font-size: 2.5rem;
    }

    canvas {
      border: 3px solid #000000;
      border-radius: 15px;
      margin-bottom: 30px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      margin-bottom: 30px;
    }

    .controls select,
    .controls input[type="button"],
    .controls input[type="range"] {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 12px 16px;
      font-size: 1rem;
      transition: border-color 0.3s, box-shadow 0.3s, transform 0.2s;
    }

    .controls select:focus,
    .controls input[type="button"]:hover,
    .controls input[type="range"]:focus {
      border-color: #007bff;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      transform: scale(1.05);
    }

    .controls input[type="range"] {
      -webkit-appearance: none;
      width: 150px;
      background: transparent;
    }

    .controls input[type="range"]::-webkit-slider-runnable-track {
      height: 10px;
      background: #007bff;
      border-radius: 6px;
    }

    .controls input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 22px;
      width: 22px;
      background: #007bff;
      border-radius: 50%;
      cursor: pointer;
      margin-top: -6px;
    }

    .controls input[type="range"]::-moz-range-thumb {
      height: 22px;
      width: 22px;
      background: #007bff;
      border-radius: 50%;
      cursor: pointer;
    }

    .controls input[type="range"]::-moz-range-track {
      height: 10px;
      background: #007bff;
      border-radius: 6px;
    }

    .controls div {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .controls span {
      font-size: 1.1rem;
      color: #007bff;
    }

    .checkboxes {
      display: flex;
      justify-content: space-around;
      margin-top: 20px;
    }

    .checkboxes input[type="checkbox"] {
      margin-right: 8px;
    }

    .checkboxes label {
      font-size: 1rem;
      color: #007bff;
    }
  </style>
</head>

<body>
  <div class="container">
    <h2>Fluid Sim</h2>

    <canvas id="theCanvas" width="600" height="240"></canvas>

    <div class="controls">
      <div>
        <select id="sizeSelect" onchange="resize()">
          <option value="10">60 x 24</option>
          <option value="8">75 x 30</option>
          <option value="6">100 x 40</option>
          <option value="5">120 x 48</option>
          <option value="4">150 x 60</option>
          <option value="3">200 x 80</option>
          <option value="2">300 x 120</option>
          <option value="1">600 x 240</option>
        </select>
      </div>
      <div>
        <input id="resetFluidButton" type="button" onclick="initFluid()" value="Reset fluid">
        <input id="stepButton" type="button" onclick="simulate()" value="Step">
        <input id="startButton" type="button" onclick="startStop()" value="Start">
      </div>
    </div>

    <div class="controls">
      <div>
        <span>Flow speed = <span id="speedValue">0.100</span></span>
        <input id="speedSlider" type="range" min="0" max="0.12" step="0.005" value="0.1" onchange="adjustSpeed()">
      </div>
      <div>
        <span>Viscosity = <span id="viscValue">0.020</span></span>
        <input id="viscSlider" type="range" min="0.005" max="0.2" step="0.005" value="0.02" onchange="adjustViscosity()">
      </div>
    </div>

    <div class="controls">
      <div>
        <select id="mouseSelect">
          <option value="draw">Draw barriers</option>
        </select>
      </div>
      <div>
        <select id="barrierSelect" onchange="placePresetBarrier()">
          <option>Barrier shapes</option>
        </select>
        <input id="clearButton" type="button" onclick="clearBarriers()" value="Clear barriers">
      </div>
    </div>

    <div class="controls">
      <div>
        <span>Plot Mode:</span>
        <select id="plotSelect" onchange="paintCanvas()">
          <option>Density</option>
          <option>Speed</option>
          <option>Velocity-Y</option>
          <option>Velocity-X</option>
          <option selected>Curl</option>
        </select>
      </div>
      <div>
        <span>Contrast:</span>
        <input id="contrastSlider" type="range" min="-10" max="10" step="1" value="0" onchange="paintCanvas()">
      </div>
    </div>

    <div class="checkboxes">
      <label><input id="forceCheck" type="checkbox" onchange="paintCanvas()"> Forces Arrow</label>
    </div>
  </div>

  <script>
    function generateLine(x, yStart, yEnd) {
      let locations = [];
      for (let y = yStart; y <= yEnd; y++) {
        locations.push([x, y]);
      }
      return locations;
    }

    function generateCircle(centerX, centerY, radius) {
      let locations = [];
      for (let x = centerX - radius; x <= centerX + radius; x++) {
        for (let y = centerY - radius; y <= centerY + radius; y++) {
          if (Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2) <= radius) {
            locations.push([x, y]);
          }
        }
      }
      return locations;
    }

    function generateDiagonal(xStart, yStart, xEnd, yEnd) {
      let locations = [];
      for (let x = xStart, y = yStart; x <= xEnd && y <= yEnd; x++, y++) {
        locations.push([x, y]);
      }
      return locations;
    }
    var barrierList = [{
        name: "Short line",
        locations: generateLine(12, 15, 23)
      },
      {
        name: "Long line",
        locations: generateLine(13, 11, 28)
      },
      {
        name: "Diagonal",
        locations: generateDiagonal(30, 14, 14, 31)
      },
      {
        name: "Shallow diagonal",
        locations: [
          ...generateLine(47, 18, 50),
          ...generateLine(41, 20, 41),
          ...generateLine(35, 22, 35),
          ...generateLine(32, 23, 32),
          ...generateLine(29, 24, 29),
          ...generateLine(26, 25, 26),
          ...generateLine(23, 26, 23),
          ...generateLine(20, 27, 20),
          ...generateLine(17, 28, 20)
        ]
      },
      {
        name: "Small circle",
        locations: generateCircle(16, 15, 5)
      },
      {
        name: "Large circle",
        locations: generateCircle(30, 16, 14)
      },
      {
        name: "Line with spoiler",
        locations: generateLine(16, 20, 50).concat(generateLine(16, 25, 28))
      },
      {
        name: "Circle with spoiler",
        locations: [
          ...generateCircle(40, 36, 20),
          ...generateLine(27, 37, 27),
          ...generateLine(35, 41, 27)
        ]
      },
      {
        name: "Right angle",
        locations: [
          ...generateLine(27, 36, 79),
          ...generateLine(27, 37, 27)
        ]
      },
      {
        name: "Wedge",
        locations: [
          ...generateLine(27, 36, 79),
          ...generateLine(27, 37, 27),
          ...generateLine(27, 42, 27),
          ...generateLine(27, 43, 27)
        ]
      },
      {
        name: "Airfoil",
        locations: [
          ...generateLine(17, 16, 21),
          ...generateLine(56, 17, 20),
          ...generateLine(44, 19, 50),
          ...generateLine(38, 20, 43),
          ...generateLine(14, 21, 21),
          ...generateLine(15, 22, 26)
        ]
      }
    ];
  </script>
  <script>
    var mobile = navigator.userAgent.match(/iPhone|iPad|iPod|Android|BlackBerry|Opera Mini|IEMobile/i)
    var canvas = document.getElementById('theCanvas');
    var context = canvas.getContext('2d');
    var image = context.createImageData(canvas.width, canvas.height);
    for (var i = 3; i < image.data.length; i += 4) image.data[i] = 255;
    var sizeSelect = document.getElementById('sizeSelect');
    sizeSelect.selectedIndex = 5;
    if (mobile) sizeSelect.selectedIndex = 1;
    var pxPerSquare = Number(sizeSelect.options[sizeSelect.selectedIndex].value);
    var xdim = canvas.width / pxPerSquare;
    var ydim = canvas.height / pxPerSquare;
    var stepsSlider = 20;
    var startButton = document.getElementById('startButton');
    var speedSlider = document.getElementById('speedSlider');
    var speedValue = document.getElementById('speedValue');
    var viscSlider = document.getElementById('viscSlider');
    var viscValue = document.getElementById('viscValue');
    var mouseSelect = document.getElementById('mouseSelect');
    var barrierSelect = document.getElementById('barrierSelect');
    for (var barrierIndex = 0; barrierIndex < barrierList.length; barrierIndex++) {
      var shape = document.createElement("option");
      shape.text = barrierList[barrierIndex].name;
      barrierSelect.add(shape, null);
    }
    var plotSelect = document.getElementById('plotSelect');
    var contrastSlider = document.getElementById('contrastSlider');
    var flowlineCheck = document.getElementById('flowlineCheck');
    var running = false;
    var stepCount = 0;
    var startTime = 0;
    var four9ths = 4.0 / 9.0;
    var one9th = 1.0 / 9.0;
    var one36th = 1.0 / 36.0;
    var barrierCount = 0;
    var barrierxSum = 0;
    var barrierySum = 0;
    var mouseIsDown = false;
    var mouseX, mouseY;
    var oldMouseX = -1,
      oldMouseY = -1;
    var collectingData = false;
    var time = 0;
    var showingPeriod = false;
    canvas.addEventListener('mousedown', mouseDown, false);
    canvas.addEventListener('mousemove', mouseMove, false);
    document.body.addEventListener('mouseup', mouseUp, false);
    canvas.addEventListener('touchstart', mouseDown, false);
    canvas.addEventListener('touchmove', mouseMove, false);
    document.body.addEventListener('touchend', mouseUp, false);
    var n0 = new Array(xdim * ydim);
    var nN = new Array(xdim * ydim);
    var nS = new Array(xdim * ydim);
    var nE = new Array(xdim * ydim);
    var nW = new Array(xdim * ydim);
    var nNE = new Array(xdim * ydim);
    var nSE = new Array(xdim * ydim);
    var nNW = new Array(xdim * ydim);
    var nSW = new Array(xdim * ydim);
    var rho = new Array(xdim * ydim);
    var ux = new Array(xdim * ydim);
    var uy = new Array(xdim * ydim);
    var curl = new Array(xdim * ydim);
    var barrier = new Array(xdim * ydim);
    for (var y = 0; y < ydim; y++) {
      for (var x = 0; x < xdim; x++) {
        barrier[x + y * xdim] = false;
      }
    }
    var barrierSize = 8;
    if (mobile) barrierSize = 4;
    for (var y = (ydim / 2) - barrierSize; y <= (ydim / 2) + barrierSize; y++) {
      var x = Math.round(ydim / 3);
      barrier[x + y * xdim] = true;
    }
    var nColors = 400;
    var hexColorList = new Array(nColors + 2);
    var redList = new Array(nColors + 2);
    var greenList = new Array(nColors + 2);
    var blueList = new Array(nColors + 2);
    for (var c = 0; c <= nColors; c++) {
      var r, g, b;
      if (c < nColors / 8) {
        r = 0;
        g = 0;
        b = Math.round(255 * (c + nColors / 8) / (nColors / 4));
      } else if (c < 3 * nColors / 8) {
        r = 0;
        g = Math.round(255 * (c - nColors / 8) / (nColors / 4));
        b = 255;
      } else if (c < 5 * nColors / 8) {
        r = Math.round(255 * (c - 3 * nColors / 8) / (nColors / 4));
        g = 255;
        b = 255 - r;
      } else if (c < 7 * nColors / 8) {
        r = 255;
        g = Math.round(255 * (7 * nColors / 8 - c) / (nColors / 4));
        b = 0;
      } else {
        r = Math.round(255 * (9 * nColors / 8 - c) / (nColors / 4));
        g = 0;
        b = 0;
      }
      redList[c] = r;
      greenList[c] = g;
      blueList[c] = b;
      hexColorList[c] = rgbToHex(r, g, b);
    }
    redList[nColors + 1] = 0;
    greenList[nColors + 1] = 0;
    blueList[nColors + 1] = 0;
    hexColorList[nColors + 1] = rgbToHex(0, 0, 0);

    function componentToHex(c) {
      var hex = c.toString(16);
      return hex.length == 1 ? "0" + hex : hex;
    }

    function rgbToHex(r, g, b) {
      return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
    }
    var transBlackArraySize = 50;
    var transBlackArray = new Array(transBlackArraySize);
    for (var i = 0; i < transBlackArraySize; i++) {
      transBlackArray[i] = "rgba(0,0,0," + Number(i / transBlackArraySize).toFixed(2) + ")";
    }
    initFluid();
    window.requestAnimFrame = (function(callback) {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          window.setTimeout(callback, 1);
        };
    })();

    function simulate() {
      var stepsPerFrame = 20;
      setBoundaries();
      var pushing = false;
      var pushX, pushY, pushUX, pushUY;
      if (mouseIsDown && mouseSelect.selectedIndex == 2) {
        if (oldMouseX >= 0) {
          var gridLoc = canvasToGrid(mouseX, mouseY);
          pushX = gridLoc.x;
          pushY = gridLoc.y;
          pushUX = (mouseX - oldMouseX) / pxPerSquare / stepsPerFrame;
          pushUY = -(mouseY - oldMouseY) / pxPerSquare / stepsPerFrame;
          if (Math.abs(pushUX) > 0.1) pushUX = 0.1 * Math.abs(pushUX) / pushUX;
          if (Math.abs(pushUY) > 0.1) pushUY = 0.1 * Math.abs(pushUY) / pushUY;
          pushing = true;
        }
        oldMouseX = mouseX;
        oldMouseY = mouseY;
      } else {
        oldMouseX = -1;
        oldMouseY = -1;
      }
      for (var step = 0; step < stepsPerFrame; step++) {
        collide();
        stream();
        if (pushing) push(pushX, pushY, pushUX, pushUY);
        time++;
        if (showingPeriod && (barrierFy > 0) && (lastBarrierFy <= 0)) {
          var thisFyOscTime = time - barrierFy / (barrierFy - lastBarrierFy);
          if (lastFyOscTime > 0) {
            var period = thisFyOscTime - lastFyOscTime;
            dataArea.innerHTML += Number(period).toFixed(2) + "\n";
            dataArea.scrollTop = dataArea.scrollHeight;
          }
          lastFyOscTime = thisFyOscTime;
        }
        lastBarrierFy = barrierFy;
      }
      paintCanvas();
      if (running) {
        requestAnimFrame(function() {
          simulate();
        });
      }
    }

    function setBoundaries() {
      var u0 = Number(speedSlider.value);
      for (var x = 0; x < xdim; x++) {
        setEquil(x, 0, u0, 0, 1);
        setEquil(x, ydim - 1, u0, 0, 1);
      }
      for (var y = 1; y < ydim - 1; y++) {
        setEquil(0, y, u0, 0, 1);
        setEquil(xdim - 1, y, u0, 0, 1);
      }
    }

    function collide() {
      var viscosity = Number(viscSlider.value);
      var omega = 1 / (3 * viscosity + 0.5);
      for (var y = 1; y < ydim - 1; y++) {
        for (var x = 1; x < xdim - 1; x++) {
          var i = x + y * xdim;
          var thisrho = n0[i] + nN[i] + nS[i] + nE[i] + nW[i] + nNW[i] + nNE[i] + nSW[i] + nSE[i];
          rho[i] = thisrho;
          var thisux = (nE[i] + nNE[i] + nSE[i] - nW[i] - nNW[i] - nSW[i]) / thisrho;
          ux[i] = thisux;
          var thisuy = (nN[i] + nNE[i] + nNW[i] - nS[i] - nSE[i] - nSW[i]) / thisrho;
          uy[i] = thisuy
          var one9thrho = one9th * thisrho;
          var one36thrho = one36th * thisrho;
          var ux3 = 3 * thisux;
          var uy3 = 3 * thisuy;
          var ux2 = thisux * thisux;
          var uy2 = thisuy * thisuy;
          var uxuy2 = 2 * thisux * thisuy;
          var u2 = ux2 + uy2;
          var u215 = 1.5 * u2;
          n0[i] += omega * (four9ths * thisrho * (1 - u215) - n0[i]);
          nE[i] += omega * (one9thrho * (1 + ux3 + 4.5 * ux2 - u215) - nE[i]);
          nW[i] += omega * (one9thrho * (1 - ux3 + 4.5 * ux2 - u215) - nW[i]);
          nN[i] += omega * (one9thrho * (1 + uy3 + 4.5 * uy2 - u215) - nN[i]);
          nS[i] += omega * (one9thrho * (1 - uy3 + 4.5 * uy2 - u215) - nS[i]);
          nNE[i] += omega * (one36thrho * (1 + ux3 + uy3 + 4.5 * (u2 + uxuy2) - u215) - nNE[i]);
          nSE[i] += omega * (one36thrho * (1 + ux3 - uy3 + 4.5 * (u2 - uxuy2) - u215) - nSE[i]);
          nNW[i] += omega * (one36thrho * (1 - ux3 + uy3 + 4.5 * (u2 - uxuy2) - u215) - nNW[i]);
          nSW[i] += omega * (one36thrho * (1 - ux3 - uy3 + 4.5 * (u2 + uxuy2) - u215) - nSW[i]);
        }
      }
      for (var y = 1; y < ydim - 2; y++) {
        nW[xdim - 1 + y * xdim] = nW[xdim - 2 + y * xdim];
        nNW[xdim - 1 + y * xdim] = nNW[xdim - 2 + y * xdim];
        nSW[xdim - 1 + y * xdim] = nSW[xdim - 2 + y * xdim];
      }
    }

    function stream() {
      barrierCount = 0;
      barrierxSum = 0;
      barrierySum = 0;
      barrierFx = 0.0;
      barrierFy = 0.0;
      for (var y = ydim - 2; y > 0; y--) {
        for (var x = 1; x < xdim - 1; x++) {
          nN[x + y * xdim] = nN[x + (y - 1) * xdim];
          nNW[x + y * xdim] = nNW[x + 1 + (y - 1) * xdim];
        }
      }
      for (var y = ydim - 2; y > 0; y--) {
        for (var x = xdim - 2; x > 0; x--) {
          nE[x + y * xdim] = nE[x - 1 + y * xdim];
          nNE[x + y * xdim] = nNE[x - 1 + (y - 1) * xdim];
        }
      }
      for (var y = 1; y < ydim - 1; y++) {
        for (var x = xdim - 2; x > 0; x--) {
          nS[x + y * xdim] = nS[x + (y + 1) * xdim];
          nSE[x + y * xdim] = nSE[x - 1 + (y + 1) * xdim];
        }
      }
      for (var y = 1; y < ydim - 1; y++) {
        for (var x = 1; x < xdim - 1; x++) {
          nW[x + y * xdim] = nW[x + 1 + y * xdim];
          nSW[x + y * xdim] = nSW[x + 1 + (y + 1) * xdim];
        }
      }
      for (var y = 1; y < ydim - 1; y++) {
        for (var x = 1; x < xdim - 1; x++) {
          if (barrier[x + y * xdim]) {
            var index = x + y * xdim;
            nE[x + 1 + y * xdim] = nW[index];
            nW[x - 1 + y * xdim] = nE[index];
            nN[x + (y + 1) * xdim] = nS[index];
            nS[x + (y - 1) * xdim] = nN[index];
            nNE[x + 1 + (y + 1) * xdim] = nSW[index];
            nNW[x - 1 + (y + 1) * xdim] = nSE[index];
            nSE[x + 1 + (y - 1) * xdim] = nNW[index];
            nSW[x - 1 + (y - 1) * xdim] = nNE[index];
            barrierCount++;
            barrierxSum += x;
            barrierySum += y;
            barrierFx += nE[index] + nNE[index] + nSE[index] - nW[index] - nNW[index] - nSW[index];
            barrierFy += nN[index] + nNE[index] + nNW[index] - nS[index] - nSE[index] - nSW[index];
          }
        }
      }
    }

    function setEquil(x, y, newux, newuy, newrho) {
      var i = x + y * xdim;
      if (typeof newrho == 'undefined') {
        newrho = rho[i];
      }
      var ux3 = 3 * newux;
      var uy3 = 3 * newuy;
      var ux2 = newux * newux;
      var uy2 = newuy * newuy;
      var uxuy2 = 2 * newux * newuy;
      var u2 = ux2 + uy2;
      var u215 = 1.5 * u2;
      n0[i] = four9ths * newrho * (1 - u215);
      nE[i] = one9th * newrho * (1 + ux3 + 4.5 * ux2 - u215);
      nW[i] = one9th * newrho * (1 - ux3 + 4.5 * ux2 - u215);
      nN[i] = one9th * newrho * (1 + uy3 + 4.5 * uy2 - u215);
      nS[i] = one9th * newrho * (1 - uy3 + 4.5 * uy2 - u215);
      nNE[i] = one36th * newrho * (1 + ux3 + uy3 + 4.5 * (u2 + uxuy2) - u215);
      nSE[i] = one36th * newrho * (1 + ux3 - uy3 + 4.5 * (u2 - uxuy2) - u215);
      nNW[i] = one36th * newrho * (1 - ux3 + uy3 + 4.5 * (u2 - uxuy2) - u215);
      nSW[i] = one36th * newrho * (1 - ux3 - uy3 + 4.5 * (u2 + uxuy2) - u215);
      rho[i] = newrho;
      ux[i] = newux;
      uy[i] = newuy;
    }

    function paintCanvas() {
      var cIndex = 0;
      var contrast = Math.pow(1.2, Number(contrastSlider.value));
      var plotType = plotSelect.selectedIndex;
      if (plotType == 4) computeCurl();
      for (var y = 0; y < ydim; y++) {
        for (var x = 0; x < xdim; x++) {
          if (barrier[x + y * xdim]) {
            cIndex = nColors + 1;
          } else {
            if (plotType == 0) {
              cIndex = Math.round(nColors * ((rho[x + y * xdim] - 1) * 6 * contrast + 0.5));
            } else if (plotType == 2) {
              cIndex = Math.round(nColors * (ux[x + y * xdim] * 2 * contrast + 0.5));
            } else if (plotType == 3) {
              cIndex = Math.round(nColors * (uy[x + y * xdim] * 2 * contrast + 0.5));
            } else if (plotType == 1) {
              var speed = Math.sqrt(ux[x + y * xdim] * ux[x + y * xdim] + uy[x + y * xdim] * uy[x + y * xdim]);
              cIndex = Math.round(nColors * (speed * 4 * contrast));
            } else {
              cIndex = Math.round(nColors * (curl[x + y * xdim] * 5 * contrast + 0.5));
            }
            if (cIndex < 0) cIndex = 0;
            if (cIndex > nColors) cIndex = nColors;
          }
          colorSquare(x, y, redList[cIndex], greenList[cIndex], blueList[cIndex]);
        }
      }
      context.putImageData(image, 0, 0);
      if (forceCheck.checked) drawForceArrow(barrierxSum / barrierCount, barrierySum / barrierCount, barrierFx, barrierFy);
    }

    function colorSquare(x, y, r, g, b) {
      var flippedy = ydim - y - 1;
      for (var py = flippedy * pxPerSquare; py < (flippedy + 1) * pxPerSquare; py++) {
        for (var px = x * pxPerSquare; px < (x + 1) * pxPerSquare; px++) {
          var index = (px + py * image.width) * 4;
          image.data[index + 0] = r;
          image.data[index + 1] = g;
          image.data[index + 2] = b;
        }
      }
    }

    function computeCurl() {
      for (var y = 1; y < ydim - 1; y++) {
        for (var x = 1; x < xdim - 1; x++) {
          curl[x + y * xdim] = uy[x + 1 + y * xdim] - uy[x - 1 + y * xdim] - ux[x + (y + 1) * xdim] + ux[x + (y - 1) * xdim];
        }
      }
    }

    function drawForceArrow(x, y, Fx, Fy) {
      const arrowWidth = 3;
      const arrowLength = 25;
      const arrowHeadLength = 30;
      const arrowHeadWidth = 12;
      context.save();
      context.fillStyle = "rgba(100,100,100,0.7)";
      context.translate((x + 0.5) * pxPerSquare, canvas.height - (y + 0.5) * pxPerSquare);
      const angle = Math.atan2(-Fy, Fx);
      context.rotate(angle);
      const magF = Math.sqrt(Fx * Fx + Fy * Fy);
      const scaleFactor = 4 * magF;
      context.beginPath();
      context.moveTo(0, arrowWidth);
      context.lineTo(scaleFactor * arrowLength, arrowWidth);
      context.lineTo(scaleFactor * arrowLength, arrowHeadWidth);
      context.lineTo(scaleFactor * (arrowLength + arrowHeadLength), 0);
      context.lineTo(scaleFactor * arrowLength, -arrowHeadWidth);
      context.lineTo(scaleFactor * arrowLength, -arrowWidth);
      context.lineTo(0, -arrowWidth);
      context.closePath();
      context.fill();
      context.restore();
    }

    function mouseDown(e) {
      mousePressDrag(e);
    };

    function mouseMove(e) {
      if (mouseIsDown) {
        mousePressDrag(e);
      }
    };

    function mouseUp(e) {
      mouseIsDown = false;
    };

    function mousePressDrag(e) {
      e.preventDefault();
      mouseIsDown = true;
      var canvasLoc = pageToCanvas(e.pageX, e.pageY);
      if (mouseSelect.selectedIndex == 2) {
        mouseX = canvasLoc.x;
        mouseY = canvasLoc.y;
        return;
      }
      var gridLoc = canvasToGrid(canvasLoc.x, canvasLoc.y);
      if (mouseSelect.selectedIndex == 0) {
        addBarrier(gridLoc.x, gridLoc.y);
        paintCanvas();
      } else {
        removeBarrier(gridLoc.x, gridLoc.y);
      }
    }

    function pageToCanvas(pageX, pageY) {
      var canvasX = pageX - canvas.offsetLeft;
      var canvasY = pageY - canvas.offsetTop;
      return {
        x: canvasX,
        y: canvasY
      };
    }

    function canvasToGrid(canvasX, canvasY) {
      var gridX = Math.floor(canvasX / pxPerSquare);
      var gridY = Math.floor((canvas.height - 1 - canvasY) / pxPerSquare); //FIX THIS IN THE FINAL
      return {
        x: gridX,
        y: gridY
      };
    }

    function addBarrier(x, y) {
      if ((x > 1) && (x < xdim - 2) && (y > 1) && (y < ydim - 2)) {
        barrier[x + y * xdim] = true;
      }
    }

    function clearBarriers() {
      for (var x = 0; x < xdim; x++) {
        for (var y = 0; y < ydim; y++) {
          barrier[x + y * xdim] = false;
        }
      }
      paintCanvas();
    }

    function resize() {
      var tempRho = new Array(canvas.width * canvas.height);
      var tempUx = new Array(canvas.width * canvas.height);
      var tempUy = new Array(canvas.width * canvas.height);
      var tempBarrier = new Array(canvas.width * canvas.height);
      for (var y = 0; y < canvas.height; y++) {
        for (var x = 0; x < canvas.width; x++) {
          var tempIndex = x + y * canvas.width;
          var xOld = Math.floor(x / pxPerSquare);
          var yOld = Math.floor(y / pxPerSquare);
          var oldIndex = xOld + yOld * xdim;
          tempRho[tempIndex] = rho[oldIndex];
          tempUx[tempIndex] = ux[oldIndex];
          tempUy[tempIndex] = uy[oldIndex];
          tempBarrier[tempIndex] = barrier[oldIndex];
        }
      }
      var oldPxPerSquare = pxPerSquare;
      pxPerSquare = Number(sizeSelect.options[sizeSelect.selectedIndex].value);
      var growRatio = oldPxPerSquare / pxPerSquare;
      xdim = canvas.width / pxPerSquare;
      ydim = canvas.height / pxPerSquare;
      n0 = new Array(xdim * ydim);
      nN = new Array(xdim * ydim);
      nS = new Array(xdim * ydim);
      nE = new Array(xdim * ydim);
      nW = new Array(xdim * ydim);
      nNE = new Array(xdim * ydim);
      nSE = new Array(xdim * ydim);
      nNW = new Array(xdim * ydim);
      nSW = new Array(xdim * ydim);
      rho = new Array(xdim * ydim);
      ux = new Array(xdim * ydim);
      uy = new Array(xdim * ydim);
      curl = new Array(xdim * ydim);
      barrier = new Array(xdim * ydim);
      for (var yNew = 0; yNew < ydim; yNew++) {
        for (var xNew = 0; xNew < xdim; xNew++) {
          var rhoTotal = 0;
          var uxTotal = 0;
          var uyTotal = 0;
          var barrierTotal = 0;
          for (var y = yNew * pxPerSquare; y < (yNew + 1) * pxPerSquare; y++) {
            for (var x = xNew * pxPerSquare; x < (xNew + 1) * pxPerSquare; x++) {
              var index = x + y * canvas.width;
              rhoTotal += tempRho[index];
              uxTotal += tempUx[index];
              uyTotal += tempUy[index];
              if (tempBarrier[index]) barrierTotal++;
            }
          }
          setEquil(xNew, yNew, uxTotal / (pxPerSquare * pxPerSquare), uyTotal / (pxPerSquare * pxPerSquare), rhoTotal / (pxPerSquare * pxPerSquare))
          curl[xNew + yNew * xdim] = 0.0;
          barrier[xNew + yNew * xdim] = (barrierTotal >= pxPerSquare * pxPerSquare / 2);
        }
      }
      setBoundaries();
      paintCanvas();
    }

    function initFluid() {
      var u0 = Number(speedSlider.value);
      for (var y = 0; y < ydim; y++) {
        for (var x = 0; x < xdim; x++) {
          setEquil(x, y, u0, 0, 1);
          curl[x + y * xdim] = 0.0;
        }
      }
      paintCanvas();
    }

    function startStop() {
      running = !running;
      if (running) {
        startButton.value = "Pause";
        simulate();
      } else {
        startButton.value = " Run ";
      }
    }

    function adjustSpeed() {
      speedValue.innerHTML = Number(speedSlider.value).toFixed(3);
    }

    function adjustViscosity() {
      viscValue.innerHTML = Number(viscSlider.value).toFixed(3);
    }

    function placePresetBarrier() {
      var index = barrierSelect.selectedIndex;
      if (index == 0) return;
      clearBarriers();
      var bCount = barrierList[index - 1].locations.length / 2;
      y:
        var xMin = barrierList[index - 1].locations[0];
      var yMin = barrierList[index - 1].locations[1];
      var yMax = yMin;
      for (var siteIndex = 2; siteIndex < 2 * bCount; siteIndex += 2) {
        if (barrierList[index - 1].locations[siteIndex] < xMin) {
          xMin = barrierList[index - 1].locations[siteIndex];
        }
        if (barrierList[index - 1].locations[siteIndex + 1] < yMin) {
          yMin = barrierList[index - 1].locations[siteIndex + 1];
        }
        if (barrierList[index - 1].locations[siteIndex + 1] > yMax) {
          yMax = barrierList[index - 1].locations[siteIndex + 1];
        }
      }
      var yAverage = Math.round((yMin + yMax) / 2);
      for (var siteIndex = 0; siteIndex < 2 * bCount; siteIndex += 2) {
        var x = barrierList[index - 1].locations[siteIndex] - xMin + Math.round(ydim / 3);
        var y = barrierList[index - 1].locations[siteIndex + 1] - yAverage + Math.round(ydim / 2);
        addBarrier(x, y);
      }
      paintCanvas();
      barrierSelect.selectedIndex = 0;
    }
  </script>
</body>

</html>
